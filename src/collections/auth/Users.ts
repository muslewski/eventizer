import {
  adminOrHigherOrSelf,
  fieldAdminOrHigher,
  fieldModeratorOrHigher,
  moderatorOrHigherOrSelf,
  publicAccess,
} from '@/access'
import { getRoleConfig, Role, userRoles } from '@/access/hierarchy'
import { auth } from '@/auth/auth'
import { APIError, type CollectionConfig } from 'payload'

export const Users: CollectionConfig = {
  slug: 'users',
  admin: {
    useAsTitle: 'email',
    group: 'Auth',
  },
  auth: {
    disableLocalStrategy: true, // We should disable this since we use Better Auth now
    strategies: [
      {
        name: 'better-auth',
        authenticate: async ({ headers, payload }) => {
          try {
            // 1. Get user session from Better Auth using request headers
            const userSession = await auth.api.getSession({ headers })

            // 2. If no session exists, return null (not authenticated)
            if (!userSession || !userSession.user) return { user: null }

            // 3. Fetch full user data from Payload database
            const userData = await payload.findByID({
              collection: 'users',
              id: userSession?.user?.id,
            })

            // 4. Return user data in the expected format
            return {
              user: {
                ...userData,
                collection: 'users',
              },
            }
          } catch (err) {
            payload.logger.error(err)
            return { user: null }
          }
        },
      },
    ],
  },
  endpoints: [
    {
      path: '/logout',
      method: 'post',
      handler: async (req) => {
        // 1. Call Better Auth signOut to invalidate the session
        await auth.api.signOut({
          headers: req.headers,
        })

        // 2. Return success response
        return Response.json(
          {
            message: 'Token revoked successfully',
          },
          {
            status: 200,
            headers: req.headers,
          },
        )
      },
    },
  ],
  access: {
    read: moderatorOrHigherOrSelf,
    update: adminOrHigherOrSelf, // only admin or user can update its account
    delete: adminOrHigherOrSelf, // only admin or user can delete its account
    create: () => false, // everyone can create new account
  },
  hooks: {
    beforeValidate: [
      ({ req, data }) => {
        const user = req.user

        // Block protected roles for non-admins (API-level protection)
        if (!user || user.role !== 'admin') {
          if (data?.role && getRoleConfig(data.role).isProtected) {
            throw new APIError(
              'You do not have permission to assign this role.',
              400,
              undefined,
              true,
            )
          }
        }

        return data
      },
    ],
  },
  fields: [
    // id, createdAt, and updatedAt is autogenerated by Payload
    {
      name: 'profilePicture',
      type: 'upload',
      relationTo: 'media',
    },
    {
      name: 'role',
      type: 'select',
      options: [...userRoles],
      defaultValue: 'client',
      required: true,
      access: {
        read: fieldModeratorOrHigher,
        update: fieldAdminOrHigher,
      },
      admin: {
        components: {
          Field: '/components/payload/fields/roleSelect',
        },
      },
      filterOptions: ({ req, options }) => {
        // Admins can see all roles
        if (req.user?.role === 'admin') {
          return options
        }
        // Non-admins only see non-protected roles
        return options.filter((option) => {
          const roleValue = typeof option === 'string' ? option : option.value
          return !getRoleConfig(roleValue as Role).isProtected
        })
      },
    },

    {
      name: 'name',
      type: 'text',
      required: true,
      index: true,
    },
    {
      name: 'email',
      type: 'text',
      required: true,
      unique: true,
      index: true,
    },
    {
      name: 'emailVerified',
      type: 'checkbox',
      required: true,
    },
    {
      name: 'image',
      type: 'text',
    },
  ],
}
